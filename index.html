<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Parkour 3D - HTML + Three.js</title>
  <style>
    html,body { height:100%; margin:0; background:#111; overflow:hidden; font-family: Arial, Helvetica, sans-serif }
    #overlay {
      position: absolute; top: 12px; left: 12px; color: #fff; z-index: 10;
      background: rgba(0,0,0,0.35); padding:10px 12px; border-radius:8px;
      backdrop-filter: blur(4px);
      box-shadow: 0 6px 18px rgba(0,0,0,0.6);
    }
    #instructions { font-size:14px; line-height:1.4 }
    #hud { position:absolute; right:12px; top:12px; color:#fff; background:rgba(0,0,0,0.35); padding:10px; border-radius:8px }
    canvas { display:block }
    a { color: #4cc9f0 }
  </style>
</head>
<body>
  <div id="overlay">
    <div style="font-weight:700; margin-bottom:6px">Parkour 3D — Demo</div>
    <div id="instructions">
      WASD — mover • Espaço — pular • Shift — correr • Mouse — olhar
    </div>
  </div>
  <div id="hud">Tempo: <span id="time">0.0</span>s • Saltos: <span id="jumps">0</span></div>

  <!-- Three.js from CDN -->
  <script src="https://unpkg.com/three@0.152.2/build/three.min.js"></script>

  <script>
    // Basic scene setup
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x7fbfff);

    const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);

    const renderer = new THREE.WebGLRenderer({antialias:true});
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    // Lighting
    const hemi = new THREE.HemisphereLight(0xffffee, 0x444466, 1.0);
    hemi.position.set(0, 200, 0);
    scene.add(hemi);
    const dir = new THREE.DirectionalLight(0xffffff, 0.8);
    dir.position.set(5, 10, 7.5);
    scene.add(dir);

    // Simple ground
    const groundMat = new THREE.MeshStandardMaterial({color:0x2b2b2b});
    const groundGeo = new THREE.BoxGeometry(200, 1, 200);
    const ground = new THREE.Mesh(groundGeo, groundMat);
    ground.position.set(0, -0.5, 0);
    scene.add(ground);

    // Player (a simple box)
    const player = {
      mesh: new THREE.Mesh(new THREE.BoxGeometry(0.8,1.8,0.8), new THREE.MeshStandardMaterial({color:0xffdd99})),
      velocity: new THREE.Vector3(),
      speed: 6,
      onGround: false
    };
    player.mesh.position.set(0, 2, 8);
    scene.add(player.mesh);

    // Camera offset (third-person)
    const camOffset = new THREE.Vector3(0, 2.2, 5);

    // Platforms array (position x,y,z and size x,y,z)
    const platforms = [];
    function addPlatform(x,y,z, sx,sy,sz, color=0x88cc88) {
      const mat = new THREE.MeshStandardMaterial({color});
      const geo = new THREE.BoxGeometry(sx,sy,sz);
      const mesh = new THREE.Mesh(geo, mat);
      mesh.position.set(x,y,z);
      scene.add(mesh);
      platforms.push({mesh, min:new THREE.Vector3(), max:new THREE.Vector3()});
      updateAABB(platforms[platforms.length-1]);
    }

    function updateAABB(p) {
      const pos = p.mesh.position;
      const s = new THREE.Vector3();
      p.mesh.geometry.computeBoundingBox();
      p.mesh.geometry.boundingBox.getSize(s);
      p.min.copy(pos).sub(s.clone().multiplyScalar(0.5));
      p.max.copy(pos).add(s.clone().multiplyScalar(0.5));
    }

    // Level design: start platform + series of platforms as parkour
    addPlatform(0,0,10, 6,1,6, 0x6fbf73); // start
    addPlatform(0,0,0, 4,1,4, 0x7fa8ff);
    addPlatform(4,1.2,-6, 3,0.6,3, 0xffcc66);
    addPlatform(8,2.6,-12, 3,0.6,3, 0xff8866);
    addPlatform(12,4.0,-18, 4,0.6,4, 0x88ddcc);
    addPlatform(17,5.6,-25, 5,0.6,5, 0xcc88ff);
    addPlatform(23,7.2,-32, 6,0.6,6, 0xffe066);
    addPlatform(30,9.0,-40, 8,1,8, 0x66c2ff); // finish

    // Add some side obstacles
    addPlatform(2,0.7,4, 1,1.4,1, 0x993333);
    addPlatform(6,1.9,-8, 1.4,1.4,1.4, 0x334499);

    // Mark finish
    const finish = platforms[platforms.length-1];

    // Simple AABB collision detection between player and platform
    function aabbIntersect(minA, maxA, minB, maxB) {
      return (minA.x <= maxB.x && maxA.x >= minB.x) &&
             (minA.y <= maxB.y && maxA.y >= minB.y) &&
             (minA.z <= maxB.z && maxA.z >= minB.z);
    }

    function updatePlayerAABB() {
      const box = new THREE.Box3().setFromObject(player.mesh);
      return {min:box.min.clone(), max:box.max.clone()};
    }

    // Controls state
    const keys = { w:false,a:false,s:false,d:false, shift:false };
    window.addEventListener('keydown', e => {
      if (e.code === 'KeyW') keys.w = true;
      if (e.code === 'KeyA') keys.a = true;
      if (e.code === 'KeyS') keys.s = true;
      if (e.code === 'KeyD') keys.d = true;
      if (e.code === 'ShiftLeft') keys.shift = true;
      if (e.code === 'Space') { jump(); }
    });
    window.addEventListener('keyup', e => {
      if (e.code === 'KeyW') keys.w = false;
      if (e.code === 'KeyA') keys.a = false;
      if (e.code === 'KeyS') keys.s = false;
      if (e.code === 'KeyD') keys.d = false;
      if (e.code === 'ShiftLeft') keys.shift = false;
    });

    // Mouse look: rotate player toward mouse movement
    let yaw = 0;
    let pitch = 0;
    let pointerLocked = false;
    renderer.domElement.addEventListener('click', ()=> renderer.domElement.requestPointerLock());
    document.addEventListener('pointerlockchange', ()=> { pointerLocked = !!document.pointerLockElement; });
    document.addEventListener('mousemove', (e)=>{
      if (!pointerLocked) return;
      yaw -= e.movementX * 0.0025;
      pitch -= e.movementY * 0.0025;
      pitch = Math.max(-1.2, Math.min(1.2, pitch));
    });

    // Jump
    let jumpCount = 0;
    const hudJumps = document.getElementById('jumps');
    function jump() {
      if (player.onGround) {
        player.velocity.y = 8.2; // initial jump speed
        player.onGround = false;
        jumpCount++;
        hudJumps.textContent = jumpCount;
      }
    }

    // Basic stopwatch
    let startTime = performance.now();
    const timeEl = document.getElementById('time');

    // Main loop
    const clock = new THREE.Clock();
    function animate() {
      const dt = Math.min(0.05, clock.getDelta());

      // Movement input
      const dir = new THREE.Vector3();
      if (keys.w) dir.z -= 1;
      if (keys.s) dir.z += 1;
      if (keys.a) dir.x -= 1;
      if (keys.d) dir.x += 1;
      if (dir.lengthSq() > 0) dir.normalize();

      // speed
      const baseSpeed = keys.shift ? player.speed * 1.6 : player.speed;
      // rotate movement by yaw
      const forward = new THREE.Vector3(Math.sin(yaw),0,Math.cos(yaw));
      const right = new THREE.Vector3(Math.cos(yaw),0,-Math.sin(yaw));
      const move = new THREE.Vector3();
      move.addScaledVector(forward, dir.z * baseSpeed * dt);
      move.addScaledVector(right, dir.x * baseSpeed * dt);

      // Apply horizontal move
      player.mesh.position.add(move);

      // Gravity
      player.velocity.y -= 20 * dt; // gravity
      player.mesh.position.y += player.velocity.y * dt;

      // Update AABB and collision with platforms
      const pBox = updatePlayerAABB();

      // Assume not on ground; test collision pairs
      player.onGround = false;
      for (let p of platforms) {
        updateAABB(p);
        const platMin = p.min, platMax = p.max;
        if (aabbIntersect(pBox.min, pBox.max, platMin, platMax)) {
          // Determine penetration along Y
          const prevY = player.mesh.position.y - player.velocity.y * dt;
          // If previous bottom was above platform top, land on top
          const playerBottom = pBox.min.y;
          const platTop = platMax.y;
          if (playerBottom <= platTop + 0.15 && (player.mesh.position.y - player.velocity.y*dt) >= platTop - 0.5) {
            // land on platform
            player.mesh.position.y = platTop + ( (pBox.max.y - pBox.min.y) / 2 );
            player.velocity.y = 0;
            player.onGround = true;
          } else {
            // Simple horizontal collision push-out — push player out along X/Z
            const overlapX = Math.min(pBox.max.x, platMax.x) - Math.max(pBox.min.x, platMin.x);
            const overlapZ = Math.min(pBox.max.z, platMax.z) - Math.max(pBox.min.z, platMin.z);
            if (overlapX < overlapZ) {
              // push along X
              if (pBox.min.x < platMin.x) player.mesh.position.x -= overlapX + 0.01;
              else player.mesh.position.x += overlapX + 0.01;
            } else {
              if (pBox.min.z < platMin.z) player.mesh.position.z -= overlapZ + 0.01;
              else player.mesh.position.z += overlapZ + 0.01;
            }
          }
          // update player AABB after push
          Object.assign(pBox, updatePlayerAABB());
        }
      }

      // Prevent falling infinitely
      if (player.mesh.position.y < -40) {
        resetPlayer();
      }

      // Rotate player visual to face yaw
      player.mesh.rotation.y = yaw;

      // Camera follow
      const camTarget = player.mesh.position.clone().add(new THREE.Vector3(0,1.0,0));
      const camPos = camTarget.clone().add(new THREE.Vector3(
        Math.sin(yaw) * camOffset.z,
        camOffset.y,
        Math.cos(yaw) * camOffset.z
      ));
      camera.position.lerp(camPos, 0.14);
      camera.lookAt(camTarget);

      // Check finish
      const finishBox = {min:finish.min, max:finish.max};
      const playerBox = updatePlayerAABB();
      if (aabbIntersect(playerBox.min, playerBox.max, finishBox.min, finishBox.max)) {
        const total = ((performance.now() - startTime) / 1000).toFixed(2);
        setTimeout(()=>{ alert('Você completou o percurso! Tempo: ' + total + 's • Saltos: ' + jumpCount); resetLevel(); }, 120);
      }

      // update HUD
      timeEl.textContent = ((performance.now() - startTime)/1000).toFixed(2);

      renderer.render(scene, camera);
      requestAnimationFrame(animate);
    }

    function resetPlayer() {
      player.mesh.position.set(0,2,8);
      player.velocity.set(0,0,0);
      yaw = 0; pitch = 0;
    }

    function resetLevel() {
      resetPlayer();
      startTime = performance.now();
      jumpCount = 0;
      hudJumps.textContent = jumpCount;
    }

    // Resize
    window.addEventListener('resize', ()=>{
      camera.aspect = window.innerWidth/window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    // Start
    resetLevel();
    animate();

    // Helpful note in console
    console.log('Parkour 3D iniciado — clique no jogo para controlar o mouse.');
  </script>
</body>
</html>
