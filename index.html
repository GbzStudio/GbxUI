<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Parkour 3D — Versão Avançada</title>
  <style>
    html,body{height:100%;margin:0;background:#0b1020;overflow:hidden;font-family:Inter,Arial}
    #ui{position:fixed;left:12px;top:12px;color:#e6f0ff;z-index:20;background:rgba(6,10,20,0.45);padding:10px;border-radius:10px;backdrop-filter:blur(6px)}
    #hud{position:fixed;right:12px;top:12px;color:#e6f0ff;z-index:20;background:rgba(6,10,20,0.45);padding:10px;border-radius:10px}
    .label{font-weight:700;margin-bottom:6px}
    button{background:#2b4bff;color:white;border:0;padding:6px 10px;border-radius:6px;cursor:pointer}
    a{color:#7bd389}
    canvas{display:block}
  </style>
</head>
<body>
  <div id="ui">
    <div class="label">Parkour 3D — Avançado</div>
    <div>WASD: mover • Espaço: pular • Shift: correr • Click: travar mouse</div>
    <div style="margin-top:8px"><button id="regen">Gerar novo percurso</button> <button id="toggleAI">AI Director: ON</button></div>
    <div style="margin-top:8px;font-size:13px;color:#bcd">AI ajusta dificuldade automaticamente</div>
  </div>
  <div id="hud">Tempo: <span id="time">0.00</span>s • Saltos: <span id="jumps">0</span> • Dificuldade: <span id="diff">Normal</span></div>

  <script type="module">
    import * as THREE from 'https://unpkg.com/three@0.152.2/build/three.module.js';
    import { PointerLockControls } from 'https://unpkg.com/three@0.152.2/examples/jsm/controls/PointerLockControls.js';
    import { EffectComposer } from 'https://unpkg.com/three@0.152.2/examples/jsm/postprocessing/EffectComposer.js';
    import { RenderPass } from 'https://unpkg.com/three@0.152.2/examples/jsm/postprocessing/RenderPass.js';
    import { UnrealBloomPass } from 'https://unpkg.com/three@0.152.2/examples/jsm/postprocessing/UnrealBloomPass.js';
    import { SMAAPass } from 'https://unpkg.com/three@0.152.2/examples/jsm/postprocessing/SMAAPass.js';

    // --- Scene & Renderer ---
    const scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x0b1020, 0.01);

    const renderer = new THREE.WebGLRenderer({antialias:true});
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    document.body.appendChild(renderer.domElement);

    const camera = new THREE.PerspectiveCamera(70, window.innerWidth/window.innerHeight, 0.1, 1000);
    camera.position.set(0,2,8);

    // Postprocessing
    const composer = new EffectComposer(renderer);
    composer.addPass(new RenderPass(scene, camera));
    composer.addPass(new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 0.25, 0.8, 0.1));
    composer.addPass(new SMAAPass(window.innerWidth * renderer.getPixelRatio(), window.innerHeight * renderer.getPixelRatio()));

    // Lights
    const hemi = new THREE.HemisphereLight(0xddeeff, 0x222233, 0.9);
    scene.add(hemi);
    const sun = new THREE.DirectionalLight(0xffffff, 1.0);
    sun.position.set(10,20,10);
    sun.castShadow = true;
    sun.shadow.mapSize.set(2048,2048);
    sun.shadow.camera.left = -50; sun.shadow.camera.right = 50; sun.shadow.camera.top = 50; sun.shadow.camera.bottom = -50;
    scene.add(sun);

    // Environment subtle ground
    const ground = new THREE.Mesh(new THREE.PlaneGeometry(400,400), new THREE.MeshStandardMaterial({color:0x0d1630, roughness:0.9}));
    ground.rotation.x = -Math.PI/2;
    ground.receiveShadow = true;
    ground.position.y = -1;
    scene.add(ground);

    // Player controller (character capsule simplified as box)
    const player = {
      mesh: new THREE.Mesh(new THREE.BoxGeometry(0.9,1.8,0.9), new THREE.MeshStandardMaterial({color:0xfff0c1})),
      velocity: new THREE.Vector3(),
      speed: 6.5,
      onGround: false
    };
    player.mesh.castShadow = true;
    player.mesh.position.set(0,2,10);
    scene.add(player.mesh);

    // Camera follow offset
    const camOffset = new THREE.Vector3(0,1.6,5.2);

    // Platforms container
    const platforms = [];

    function createPlatform(x,y,z,w,h,d, color=0x6fbf73){
      const mat = new THREE.MeshStandardMaterial({color, metalness:0.1, roughness:0.7});
      const geo = new THREE.BoxGeometry(w,h,d);
      const mesh = new THREE.Mesh(geo, mat);
      mesh.position.set(x,y,z);
      mesh.castShadow = true; mesh.receiveShadow = true;
      scene.add(mesh);
      const bbox = new THREE.Box3().setFromObject(mesh);
      platforms.push({mesh, bbox});
      return mesh;
    }

    // AI Director (difficulty manager): observes player performance and adjusts level params
    const AIDirector = {
      enabled: true,
      difficulty: 1.0, // 0.5 easy - 2.0 hard
      recentTimes: [],
      recentJumps: [],
      observeRun(timeSec, jumps){
        this.recentTimes.push(timeSec); if(this.recentTimes.length>6) this.recentTimes.shift();
        this.recentJumps.push(jumps); if(this.recentJumps.length>6) this.recentJumps.shift();
        this.adjustDifficulty();
      },
      adjustDifficulty(){
        // simple heuristic: if player completes faster than average, increase difficulty; if slower, decrease
        const avgTime = this.recentTimes.reduce((a,b)=>a+b,0)/this.recentTimes.length || 999;
        if (avgTime < 12 && this.recentTimes.length>=3) this.difficulty = Math.min(2.0, this.difficulty + 0.08);
        else if (avgTime > 18 && this.recentTimes.length>=3) this.difficulty = Math.max(0.6, this.difficulty - 0.08);
        // update UI
        updateDifficultyLabel();
      }
    };

    function updateDifficultyLabel(){
      const el = document.getElementById('diff');
      const val = AIDirector.difficulty;
      let name = 'Normal'; if(val>1.4) name='Difícil'; else if(val<0.8) name='Fácil';
      el.textContent = name + ' (' + val.toFixed(2) + ')';
    }

    // Procedural level generator influenced by difficulty
    function generateLevel(seed=Date.now()){
      // clear old
      for(const p of platforms){ scene.remove(p.mesh); }
      platforms.length = 0;

      // seed RNG
      let s = seed % 2147483647;
      function rand(){ s = (s * 16807) % 2147483647; return (s-1)/2147483646; }

      const baseX = 0, baseY = 0, baseZ = 10;
      // start platform
      createPlatform(baseX, baseY, baseZ, 8,1.2,8, 0x4fb07f);

      // create a chain of platforms. difficulty stretches gaps and reduces sizes
      const count = Math.floor(8 + AIDirector.difficulty * 6);
      let x = baseX, y = baseY, z = baseZ;
      for(let i=0;i<count;i++){
        const gap = 3.5 + rand() * (2.0 + AIDirector.difficulty*2.5);
        const dx = (rand()-0.5) * 6.0 * (0.3 + AIDirector.difficulty*0.6);
        z -= gap; x += dx; y += (rand()-0.4) * 1.2;
        const w = Math.max(1.0, 2.8 - AIDirector.difficulty*0.9 + rand()*2.0);
        const d = Math.max(1.2, 2.4 - AIDirector.difficulty*0.9 + rand()*2.8);
        const h = 0.6 + rand()*0.8;
        createPlatform(x,y,z,w,h,d, 0x88c0ff + Math.floor(rand()*0x005500));
      }

      // final large platform as finish
      createPlatform(x+6, y+2, z-8, 10,1.2,10, 0xffd166);
    }

    // Simple enemies (bots) that try to run the course using basic decision-making
    const bots = [];
    function spawnBot(name, color=0xff6666){
      const bot = {
        mesh: new THREE.Mesh(new THREE.BoxGeometry(0.7,1.6,0.7), new THREE.MeshStandardMaterial({color})),
        velocity: new THREE.Vector3(),
        targetIndex: 1, // which platform index it's heading to
      };
      bot.mesh.castShadow = true;
      bot.mesh.position.copy(platforms[0].mesh.position).add(new THREE.Vector3(0,1.2,0));
      scene.add(bot.mesh);
      bots.push(bot);
      return bot;
    }

    // Bot AI update: simple state machine — navigate to next platform center and jump when gap detected
    function updateBots(dt){
      if (platforms.length===0) return;
      for(const bot of bots){
        const targetPlat = platforms[Math.min(bot.targetIndex, platforms.length-1)];
        if(!targetPlat) continue;
        const targetPos = targetPlat.mesh.position.clone(); targetPos.y += 1.0;
        const dir = targetPos.clone().sub(bot.mesh.position);
        const dist = dir.length();
        dir.y = 0; dir.normalize();
        // move horizontally
        bot.mesh.position.addScaledVector(dir, Math.min(3.2 * AIDirector.difficulty * dt, dist));
        // if near edge, and platform ahead is higher or there's a gap, attempt jump
        if (dist < 1.1){ bot.targetIndex++; }
        // simple gravity
        bot.velocity.y -= 20 * dt;
        bot.mesh.position.y += bot.velocity.y * dt;
        // if bot falls below -20, respawn
        if (bot.mesh.position.y < -20){ bot.mesh.position.copy(platforms[0].mesh.position).add(new THREE.Vector3(Math.random()*1,1.2,Math.random()*1)); bot.velocity.set(0,0,0); bot.targetIndex = 1; }
        // ground collision: stand on nearest platform if overlapping
        const botBox = new THREE.Box3().setFromObject(bot.mesh);
        for(const p of platforms){
          const pBox = p.bbox;
          if (botBox.intersectsBox(pBox)){
            const platTop = pBox.max.y;
            if (bot.mesh.position.y - 0.8 <= platTop + 0.2){ bot.mesh.position.y = platTop + 0.8; bot.velocity.y = 0; }
          }
        }
      }
    }

    // Collision helpers
    function aabbIntersect(boxA, boxB){
      return boxA.intersectsBox(boxB);
    }

    // Player collision & movement
    const keys = { w:false,a:false,s:false,d:false, shift:false };
    window.addEventListener('keydown', e=>{ if(e.code==='KeyW') keys.w=true; if(e.code==='KeyS') keys.s=true; if(e.code==='KeyA') keys.a=true; if(e.code==='KeyD') keys.d=true; if(e.code==='ShiftLeft') keys.shift=true; if(e.code==='Space') tryJump(); });
    window.addEventListener('keyup', e=>{ if(e.code==='KeyW') keys.w=false; if(e.code==='KeyS') keys.s=false; if(e.code==='KeyA') keys.a=false; if(e.code==='KeyD') keys.d=false; if(e.code==='ShiftLeft') keys.shift=false; });

    const controls = new PointerLockControls(camera, document.body);
    document.body.addEventListener('click', ()=> controls.lock());
    controls.addEventListener('lock', ()=>console.log('Pointer locked'));

    function tryJump(){ if(player.onGround){ player.velocity.y = 8.6; player.onGround = false; jumpCount++; document.getElementById('jumps').textContent = jumpCount; } }

    // HUD & stats
    let jumpCount = 0; const timeEl = document.getElementById('time');
    let levelStart = performance.now();

    // Level lifecycle
    function startRun(){ levelStart = performance.now(); jumpCount = 0; document.getElementById('jumps').textContent = 0; }

    function endRun(){ const total = (performance.now()-levelStart)/1000; AIDirector.observeRun(total, jumpCount); }

    // Generate initial
    generateLevel();
    // spawn a couple of bots
    spawnBot('BotA', 0xff6666); spawnBot('BotB', 0x66ff99);

    // UI buttons
    document.getElementById('regen').addEventListener('click', ()=>{ generateLevel(Date.now()); bots.forEach(b=>scene.remove(b.mesh)); bots.length=0; spawnBot('BotA',0xff6666); startRun(); });
    const toggleAI = document.getElementById('toggleAI'); toggleAI.addEventListener('click', ()=>{ AIDirector.enabled = !AIDirector.enabled; toggleAI.textContent = 'AI Director: ' + (AIDirector.enabled? 'ON':'OFF'); });

    // Main loop
    const clock = new THREE.Clock();
    function animate(){
      const dt = Math.min(0.05, clock.getDelta());

      // Movement input relative to camera yaw
      const yaw = camera.rotation.y;
      const dir = new THREE.Vector3();
      if(keys.w) dir.z -= 1; if(keys.s) dir.z += 1; if(keys.a) dir.x -= 1; if(keys.d) dir.x += 1;
      if(dir.lengthSq()>0) dir.normalize();
      const forward = new THREE.Vector3(Math.sin(yaw),0,Math.cos(yaw));
      const right = new THREE.Vector3(Math.cos(yaw),0,-Math.sin(yaw));
      const move = new THREE.Vector3();
      const baseSpeed = keys.shift? player.speed * 1.6 : player.speed;
      move.addScaledVector(forward, dir.z * baseSpeed * dt);
      move.addScaledVector(right, dir.x * baseSpeed * dt);
      player.mesh.position.add(move);

      // apply gravity
      player.velocity.y -= 20 * dt;
      player.mesh.position.y += player.velocity.y * dt;

      // collision with platforms
      const pBox = new THREE.Box3().setFromObject(player.mesh);
      player.onGround = false;
      for(const p of platforms){
        p.bbox = new THREE.Box3().setFromObject(p.mesh);
        if (pBox.intersectsBox(p.bbox)){
          const platTop = p.bbox.max.y;
          if (player.mesh.position.y - 0.9 <= platTop + 0.2){ player.mesh.position.y = platTop + 0.9; player.velocity.y = 0; player.onGround = true; }
          else {
            // pushback simple
            const overlapX = Math.min(pBox.max.x, p.bbox.max.x) - Math.max(pBox.min.x, p.bbox.min.x);
            const overlapZ = Math.min(pBox.max.z, p.bbox.max.z) - Math.max(pBox.min.z, p.bbox.min.z);
            if (overlapX < overlapZ){ if(pBox.getCenter(new THREE.Vector3()).x < p.bbox.getCenter(new THREE.Vector3()).x) player.mesh.position.x -= overlapX+0.01; else player.mesh.position.x += overlapX+0.01; }
            else { if(pBox.getCenter(new THREE.Vector3()).z < p.bbox.getCenter(new THREE.Vector3()).z) player.mesh.position.z -= overlapZ+0.01; else player.mesh.position.z += overlapZ+0.01; }
          }
        }
      }

      // bots
      updateBots(dt);

      // camera follow smoothing
      const camTarget = player.mesh.position.clone().add(new THREE.Vector3(0,1.0,0));
      const desiredCam = camTarget.clone().add(new THREE.Vector3(Math.sin(camera.rotation.y)*camOffset.z, camOffset.y, Math.cos(camera.rotation.y)*camOffset.z));
      camera.position.lerp(desiredCam, 0.12);
      camera.lookAt(camTarget);

      // finish detection (last platform)
      const finishPlat = platforms[platforms.length-1];
      if (finishPlat){
        const finishBox = finishPlat.bbox;
        if (pBox.intersectsBox(finishBox)){
          endRun();
          // small celebration: bloom stronger and respawn after timeout
          composer.passes[1].strength = 1.2;
          setTimeout(()=>{ composer.passes[1].strength = 0.25; generateLevel(Date.now()); startRun(); }, 1000);
        }
      }

      // HUD update
      timeEl.textContent = ((performance.now()-levelStart)/1000).toFixed(2);
      updateDifficultyLabel();

      composer.render();
      requestAnimationFrame(animate);
    }

    // reset/start
    startRun();
    animate();

    // resize
    window.addEventListener('resize', ()=>{ camera.aspect = window.innerWidth/window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); composer.setSize(window.innerWidth, window.innerHeight); });

    // initial difficulty label
    updateDifficultyLabel();

    // debug: expose some objects
    window._parkour = { scene, player, platforms, AIDirector, bots, generateLevel };
  </script>
</body>
</html>
