<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Parkour 3D — Versão Épica (Complexa & Gigante)</title>
  <style>
    html,body{height:100%;margin:0;background:#071029;overflow:hidden;font-family:Inter,Arial,sans-serif}
    #ui{position:fixed;left:12px;top:12px;color:#e6f0ff;z-index:40;background:linear-gradient(180deg,rgba(6,10,20,0.6),rgba(6,10,30,0.35));padding:14px;border-radius:12px;backdrop-filter:blur(6px);box-shadow:0 10px 30px rgba(0,0,0,0.6)}
    #hud{position:fixed;right:12px;top:12px;color:#e6f0ff;z-index:40;background:rgba(6,10,20,0.45);padding:12px;border-radius:10px}
    button{background:#3a6fff;color:white;border:0;padding:8px 12px;border-radius:8px;cursor:pointer}
    .muted{color:#9fb3d6;font-size:13px}
    canvas{display:block}
  </style>
</head>
<body>
  <div id="ui">
    <div style="font-weight:800;font-size:16px;margin-bottom:6px">Parkour 3D — Versão Épica</div>
    <div class="muted">WASD — mover • Espaço — pular • Shift — correr • Clique — travar mouse</div>
    <div style="margin-top:8px;display:flex;gap:8px">
      <button id="regen">Gerar (seed)</button>
      <button id="toggleAI">AI Director: ON</button>
      <button id="saveSeed">Salvar Seed</button>
    </div>
    <div style="margin-top:8px" class="muted">Seed: <span id="seedLabel">-</span></div>
    <div style="margin-top:8px;color:#bcd;font-size:13px">Inclui: temas, chunks raros, power-ups, checkpoints (localStorage), bots com path heurístico, cápsula collider e pool de chunks.</div>
  </div>
  <div id="hud">Tempo: <span id="time">0.00</span>s • Saltos: <span id="jumps">0</span> • Dificuldade: <span id="diff">Normal</span> • Checkpoint: <span id="cp">0</span></div>

  <script src="https://unpkg.com/three@0.152.2/build/three.min.js"></script>

  <script>
  /*
    Parkour 3D — Versão Épica
    - Chunk manager profissional (themes, rarity, pool)
    - Seedable RNG (reprodutível)
    - Capsule collider for player
    - Power-ups (boost, slow, checkpoint)
    - AI Director adapts difficulty
    - Bots with simple path heuristic
    - Anti-lag: chunk pooling + culling
    - Checkpoints persisted in localStorage
  */

  // -------------------- Utilidades --------------------
  function RNG(seed){
    // Park-Miller LCG
    let s = seed % 2147483647;
    if(s<=0) s += 2147483646;
    return function(){ s = s * 16807 % 2147483647; return (s - 1) / 2147483646; };
  }

  function randRange(rng, a,b){ return a + (b-a) * rng(); }

  // -------------------- Cena básica --------------------
  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0x061020);
  const renderer = new THREE.WebGLRenderer({antialias:true});
  renderer.setPixelRatio(Math.min(window.devicePixelRatio,2));
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.shadowMap.enabled = true;
  document.body.appendChild(renderer.domElement);

  const camera = new THREE.PerspectiveCamera(70, window.innerWidth/window.innerHeight, 0.1, 1000);
  camera.position.set(0,2,8);

  // luzes
  const hemi = new THREE.HemisphereLight(0xddeeff,0x081220,0.9); scene.add(hemi);
  const sun = new THREE.DirectionalLight(0xffffff,1.0); sun.position.set(10,20,10); sun.castShadow=true; sun.shadow.mapSize.set(2048,2048); scene.add(sun);

  // chão
  const ground = new THREE.Mesh(new THREE.PlaneGeometry(800,800), new THREE.MeshStandardMaterial({color:0x08131f,roughness:0.98}));
  ground.rotation.x = -Math.PI/2; ground.position.y = -1; ground.receiveShadow = true; scene.add(ground);

  // -------------------- Jogador (capsule collider approximation) --------------------
  const player = {
    radius: 0.35,
    height: 1.1, // comprimento do cilindro central da cápsula
    mesh: new THREE.Mesh(new THREE.CapsuleGeometry(0.35,1.1,4,8), new THREE.MeshStandardMaterial({color:0xffd9a8})),
    velocity: new THREE.Vector3(),
    speed: 7.2,
    onGround: false,
    boostTimer:0
  };
  player.mesh.castShadow=true; scene.add(player.mesh);
  player.mesh.position.set(0,2,10);

  // câmera offset
  const camOffset = new THREE.Vector3(0,1.7,5.2);

  // -------------------- Chunk System (profissional) --------------------
  const chunkPool = []; // reuse
  const activeChunks = []; // {group, id, bbox, theme, powerups[]}
  const maxActiveChunks = 12;
  const chunkDepth = 40; // distância z entre chunks
  let globalChunkIndex = 0;

  // themes config
  const THEMES = [
    {name:'City', palette:[0x3a6fff,0x66c2ff,0x8899ff], specialChance:0.06},
    {name:'Neon', palette:[0xff66cc,0x66fff6,0xffe066], specialChance:0.05},
    {name:'Industrial', palette:[0x6b6b6b,0xff8866,0xcccccc], specialChance:0.04},
    {name:'Cloud', palette:[0xffffff,0x88ccff,0xe6f0ff], specialChance:0.03}
  ];

  // power-up types
  const POWERUP_TYPES = ['boost','slow','checkpoint','coin'];

  // helper: create chunk (either reuse or new)
  function obtainChunk(){
    if(chunkPool.length>0) return chunkPool.pop();
    const g = new THREE.Group();
    // base platform
    const base = new THREE.Mesh(new THREE.BoxGeometry(6,1.0,8), new THREE.MeshStandardMaterial({color:0x66c2ff, metalness:0.05, roughness:0.75}));
    base.name='base'; base.castShadow=true; base.receiveShadow=true; g.add(base);
    // maybe obstacles group
    const obs = new THREE.Group(); obs.name='obstacles'; g.add(obs);
    // powerups group
    const pgroup = new THREE.Group(); pgroup.name='powerups'; g.add(pgroup);
    scene.add(g);
    return g;
  }

  function releaseChunk(chunk){
    // hide and reset
    chunk.group.visible = false;
    // remove children obstacles/powerups visually (we keep but reposition)
    chunkPool.push(chunk.group);
  }

  // build chunk content procedurally with rng and theme
  function buildChunk(id, rng, theme){
    const g = obtainChunk();
    g.visible = true;
    // position by id
    const z = -(id * chunkDepth);
    const xOffset = (rng()-0.5) * Math.min(6, theme.variant || 4);
    g.position.set(xOffset, 0, z);

    // style base
    const base = g.getObjectByName('base');
    base.scale.x = 1 + rng()*1.6 - (theme.difficultyFactor||0);
    base.material.color.setHex(theme.palette[Math.floor(rng()*theme.palette.length)]);

    // clear old obstacles/powerups
    const obs = g.getObjectByName('obstacles');
    const pgroup = g.getObjectByName('powerups');
    obs.clear(); pgroup.clear();

    // obstacles: 0..2 per chunk scaling with difficulty
    const obsCount = Math.floor(randRange(rng, 0, 1 + theme.difficulty*2));
    for(let i=0;i<obsCount;i++){
      const w = 0.6 + rng()*1.6; const h = 0.6 + rng()*2.4; const d = 0.6 + rng()*1.0;
      const bx = (rng()-0.5) * (base.scale.x*3); const bz = (rng()-0.3) * 4;
      const b = new THREE.Mesh(new THREE.BoxGeometry(w,h,d), new THREE.MeshStandardMaterial({color:theme.palette[Math.floor(rng()*theme.palette.length)]}));
      b.position.set(bx, h/2 + 0.01, bz);
      b.castShadow=true; b.receiveShadow=true; obs.add(b);
    }

    // rare special chunk (with small chance)
    if(rng() < theme.specialChance){
      // add a jump pad
      const pad = new THREE.Mesh(new THREE.BoxGeometry(3,0.4,3), new THREE.MeshStandardMaterial({color:0xffe066}));
      pad.position.set(0,0.2,-1.5); pgroup.add(pad); pad.userData = {type:'jumpPad'};
    }

    // powerups spawn
    if(rng() < 0.25 + theme.difficulty*0.05){
      const type = POWERUP_TYPES[Math.floor(rng()*POWERUP_TYPES.length)];
      const pu = new THREE.Mesh(new THREE.SphereGeometry(0.28,12,12), new THREE.MeshStandardMaterial({emissive:0xffffaa, color:0xffffff}));
      pu.position.set((rng()-0.5)*3, 0.6, (rng()-0.3)*5);
      pu.userData = {power:type}; pgroup.add(pu);
    }

    // bounding box
    const bbox = new THREE.Box3().setFromObject(g);
    return {group:g, id:id, bbox:bbox, theme:theme};
  }

  // pool active management
  function spawnInitialChunks(seed){
    // clear current active
    for(const c of activeChunks){ releaseChunk(c); }
    activeChunks.length = 0; globalChunkIndex = 0;
    // rng
    const rng = RNG(seed);
    // pick theme
    const theme = pickTheme(rng);
    // create a handful
    for(let i=0;i<maxActiveChunks;i++){
      const c = buildChunk(globalChunkIndex++, rng, theme);
      activeChunks.push(c);
    }
  }

  function pickTheme(rng){
    const t = THEMES[Math.floor(rng()*THEMES.length)];
    // clone and add difficulty factor
    return Object.assign({}, t, {difficulty: difficulty, difficultyFactor: difficulty*0.15, variant: Math.max(1, Math.floor(difficulty))});
  }

  // update chunks based on player position (forward only)
  function updateChunksRollover(rng){
    // remove chunks far behind and create ahead
    while(activeChunks.length > 0){
      const first = activeChunks[0];
      // if player passed the center of this chunk by more than chunkDepth*0.5
      if(player.mesh.position.z < first.group.position.z - chunkDepth*0.5){
        // recycle
        const removed = activeChunks.shift();
        removed.group.visible = false; // hide
        chunkPool.push(removed.group);
        // spawn new
        const theme = pickTheme(rng);
        const newC = buildChunk(globalChunkIndex++, rng, theme);
        activeChunks.push(newC);
      } else break;
    }
  }

  // -------------------- Capsule collider vs box helper --------------------
  // approximate capsule vs AABB collision: compute closest point on box to capsule segment
  function capsuleBoxIntersect(capsuleStart, capsuleEnd, radius, box){
    // find closest point on box to segment
    // sample: clamp each segment point projection -> approximate
    const closest = new THREE.Vector3();
    box.clampPoint(capsuleStart, closest);
    const d1 = closest.distanceToSquared(capsuleStart);
    if(d1 <= radius*radius) return true;
    box.clampPoint(capsuleEnd, closest);
    const d2 = closest.distanceToSquared(capsuleEnd);
    if(d2 <= radius*radius) return true;
    // midpoint check
    const mid = capsuleStart.clone().add(capsuleEnd).multiplyScalar(0.5);
    box.clampPoint(mid, closest);
    const d3 = closest.distanceToSquared(mid);
    return d3 <= radius*radius;
  }

  // -------------------- Power-up handling --------------------
  const activePowerups = new Map(); // mesh->timer
  function collectPowerup(pu){
    const t = pu.userData.power || pu.userData.type;
    if(!t) return;
    if(t==='boost') player.boostTimer = 3.5;
    else if(t==='slow') player.boostTimer = -2.5; // negative for slow
    else if(t==='checkpoint') saveCheckpoint();
    else if(t==='coin') {/* could add score */}
    // visual remove
    pu.visible = false; pu.userData.collected = true;
  }

  // -------------------- Checkpoints (localStorage) --------------------
  let checkpointIndex = 0;
  function saveCheckpoint(){ checkpointIndex++; localStorage.setItem('parkour_checkpoint', checkpointIndex); document.getElementById('cp').textContent = checkpointIndex; }
  function loadCheckpoint(){ const v = parseInt(localStorage.getItem('parkour_checkpoint')||'0'); checkpointIndex = v; document.getElementById('cp').textContent = checkpointIndex; }

  // -------------------- AI Director (difficulty manager) --------------------
  const AIDirector = { enabled:true, difficulty:1.0, recentTimes:[], observeRun(t){ this.recentTimes.push(t); if(this.recentTimes.length>6) this.recentTimes.shift(); this.adjust(); }, adjust(){ if(this.recentTimes.length<3) return; const avg=this.recentTimes.reduce((a,b)=>a+b,0)/this.recentTimes.length; if(avg<10) this.difficulty = Math.min(2.2, this.difficulty+0.06); else if(avg>20) this.difficulty = Math.max(0.6, this.difficulty-0.06); difficulty = this.difficulty; document.getElementById('diff').textContent = (this.difficulty>1.4?'Difícil':this.difficulty<0.8?'Fácil':'Normal') + ' ('+ this.difficulty.toFixed(2)+')'; }};

  // -------------------- Bots (path heuristic) --------------------
  const bots = [];
  function spawnBot(color=0xff6666){ const bot={mesh:new THREE.Mesh(new THREE.CapsuleGeometry(0.3,0.9,4,8), new THREE.MeshStandardMaterial({color})), velocity:new THREE.Vector3(), targetChunk:1}; bot.mesh.castShadow=true; if(activeChunks[0]){ bot.mesh.position.copy(activeChunks[0].group.position).add(new THREE.Vector3((Math.random()-0.5)*1,1,0)); } scene.add(bot.mesh); bots.push(bot); }
  function updateBots(dt){ for(const b of bots){ // simple: move toward center of targetChunk
      const idx = Math.min(b.targetChunk, activeChunks.length-1); const target = activeChunks[idx].group.position.clone(); target.y += 1.0; const dir = target.clone().sub(b.mesh.position); const d = dir.length(); dir.y = 0; if(d>0.1) { dir.normalize(); b.mesh.position.addScaledVector(dir, Math.min(3.2 * difficulty * dt, d)); }
      // gravity
      b.velocity.y -= 20*dt; b.mesh.position.y += b.velocity.y*dt;
      // if overlaps chunk bbox -> advance
      const bb = activeChunks[Math.min(b.targetChunk, activeChunks.length-1)].bbox;
      if(new THREE.Box3().setFromObject(b.mesh).intersectsBox(bb)) b.targetChunk++;
      if(b.mesh.position.y < -20){ b.mesh.position.set(0,3,0); b.targetChunk = 1; b.velocity.set(0,0,0);} }
  }

  // -------------------- HUD & Controls --------------------
  const keys = {w:false,a:false,s:false,d:false,shift:false}; window.addEventListener('keydown', e=>{ if(e.code==='KeyW') keys.w=true; if(e.code==='KeyS') keys.s=true; if(e.code==='KeyA') keys.a=true; if(e.code==='KeyD') keys.d=true; if(e.code==='ShiftLeft') keys.shift=true; if(e.code==='Space') tryJump(); }); window.addEventListener('keyup', e=>{ if(e.code==='KeyW') keys.w=false; if(e.code==='KeyS') keys.s=false; if(e.code==='KeyA') keys.a=false; if(e.code==='KeyD') keys.d=false; if(e.code==='ShiftLeft') keys.shift=false; });
  let pointerLocked=false; let yaw=0, pitch=0; renderer.domElement.addEventListener('click', ()=> renderer.domElement.requestPointerLock()); document.addEventListener('pointerlockchange', ()=>{ pointerLocked = !!document.pointerLockElement; }); document.addEventListener('mousemove', e=>{ if(!pointerLocked) return; yaw -= e.movementX * 0.0025; pitch -= e.movementY * 0.0025; pitch = Math.max(-1.2, Math.min(1.2, pitch)); });

  function tryJump(){ if(player.onGround){ player.velocity.y = 9.0; player.onGround = false; jumpCount++; document.getElementById('jumps').textContent = jumpCount; }}

  // -------------------- Level lifecycle & seed --------------------
  let rng = RNG(Date.now()); let seed = Math.floor(Math.random()*2147483647); function setSeed(s){ seed = s; rng = RNG(seed); document.getElementById('seedLabel').textContent = seed; }
  setSeed(Math.floor(Math.random()*2147483647)); loadCheckpoint();

  document.getElementById('regen').addEventListener('click', ()=>{ setSeed(Math.floor(Math.random()*2147483647)); spawnInitialChunks(seed); });
  document.getElementById('saveSeed').addEventListener('click', ()=>{ localStorage.setItem('parkour_seed', seed); alert('Seed salva: '+seed); });
  document.getElementById('toggleAI').addEventListener('click', ()=>{ AIDirector.enabled = !AIDirector.enabled; document.getElementById('toggleAI').textContent = 'AI Director: ' + (AIDirector.enabled ? 'ON':'OFF'); });

  // initial spawn
  spawnInitialChunks(seed);
  // spawn bots
  spawnBot(0xff6666); spawnBot(0x66ff99);

  // -------------------- Run stats --------------------
  let jumpCount = 0; let levelStart = performance.now(); function startRun(){ levelStart = performance.now(); jumpCount = 0; document.getElementById('jumps').textContent = jumpCount; } function endRun(){ const t = (performance.now()-levelStart)/1000; if(AIDirector.enabled) AIDirector.observeRun(t); }
  startRun();

  // -------------------- Main loop --------------------
  const clock = new THREE.Clock();
  function animate(){ const dt = Math.min(0.05, clock.getDelta());

    // movement relative to yaw
    const dir = new THREE.Vector3(); if(keys.w) dir.z-=1; if(keys.s) dir.z+=1; if(keys.a) dir.x-=1; if(keys.d) dir.x+=1; if(dir.lengthSq()>0) dir.normalize();
    const forward = new THREE.Vector3(Math.sin(yaw),0,Math.cos(yaw)); const right = new THREE.Vector3(Math.cos(yaw),0,-Math.sin(yaw));
    const baseSpeed = keys.shift ? player.speed * 1.6 : player.speed; let actualSpeed = baseSpeed;
    if(player.boostTimer>0) actualSpeed *= 1.8; if(player.boostTimer<0) actualSpeed *= 0.5;
    const move = new THREE.Vector3(); move.addScaledVector(forward, dir.z * actualSpeed * dt); move.addScaledVector(right, dir.x * actualSpeed * dt);
    player.mesh.position.add(move);

    // gravity
    player.velocity.y -= 20 * dt; player.mesh.position.y += player.velocity.y * dt;

    // capsule segment endpoints
    const capsuleStart = player.mesh.position.clone().add(new THREE.Vector3(0, player.height ? player.height/2 : player.height,0));
    const capsuleEnd = player.mesh.position.clone().add(new THREE.Vector3(0, -player.height ? -player.height/2 : -player.height,0));
    // simpler approach: sample top and bottom
    const top = player.mesh.position.clone().add(new THREE.Vector3(0, player.height? player.height*0.5 : 0.9, 0));
    const bottom = player.mesh.position.clone().add(new THREE.Vector3(0, - (player.height? player.height*0.5 : 0.9), 0));

    // collision with active chunks
    player.onGround = false;
    for(const c of activeChunks){
      // update bbox
      c.bbox.setFromObject(c.group);
      // check capsule vs chunk base and obstacles
      // base
      const baseBox = new THREE.Box3().setFromObject(c.group.getObjectByName('base'));
      if(capsuleBoxIntersect(bottom, top, player.radius, baseBox)){
        // land on top if above
        const platTop = baseBox.max.y;
        if(player.mesh.position.y - 0.9 <= platTop + 0.25){ player.mesh.position.y = platTop + 0.9; player.velocity.y = 0; player.onGround = true; }
      }
      // obstacles
      const obs = c.group.getObjectByName('obstacles');
      obs.children.forEach(o=>{
        const obb = new THREE.Box3().setFromObject(o);
        if(capsuleBoxIntersect(bottom, top, player.radius, obb)){
          // simple pushout: move player away from obstacle center
          const dirAway = player.mesh.position.clone().sub(o.getWorldPosition(new THREE.Vector3())).setY(0).normalize();
          player.mesh.position.add(dirAway.multiplyScalar(0.15));
        }
      });
      // powerups
      const pgroup = c.group.getObjectByName('powerups');
      pgroup.children.forEach(pu=>{
        if(pu.userData.collected) return;
        const d2 = pu.getWorldPosition(new THREE.Vector3()).distanceToSquared(player.mesh.position);
        if(d2 < (player.radius+0.5)*(player.radius+0.5)){
          collectPowerup(pu); pu.userData.collected=true;
        }
      });
    }

    // update chunks generation/cleanup
    updateChunksRollover(rng);

    // update bots
    updateBots(dt);

    // update timers
    if(player.boostTimer !== undefined){ if(player.boostTimer>0) player.boostTimer = Math.max(0, player.boostTimer - dt); else if(player.boostTimer<0) player.boostTimer = Math.min(0, player.boostTimer + dt*0.6); }

    // falling guard
    if(player.mesh.position.y < -40) { // respawn at nearest checkpoint or start
      respawnToCheckpoint();
    }

    // camera follow smoothing
    const camTarget = player.mesh.position.clone().add(new THREE.Vector3(0,1.0,0));
    const desiredCam = camTarget.clone().add(new THREE.Vector3(Math.sin(yaw)*camOffset.z, camOffset.y, Math.cos(yaw)*camOffset.z));
    camera.position.lerp(desiredCam, 0.12);
    camera.lookAt(camTarget);

    // finish detection: if player reaches farthest chunk's end -> celebrate & continue
    const far = activeChunks[activeChunks.length-1]; if(far){ const farBox = far.bbox; if(new THREE.Box3().setFromObject(player.mesh).intersectsBox(farBox)){ // quick celebration
        scene.background = new THREE.Color(0x1a2b5f);
        setTimeout(()=> scene.background = new THREE.Color(0x061020), 500);
      }}

    // HUD
    document.getElementById('time').textContent = ((performance.now()-levelStart)/1000).toFixed(2);

    renderer.render(scene, camera);
    requestAnimationFrame(animate);
  }

  // -------------------- Respawn & checkpoints --------------------
  function respawnToCheckpoint(){ // try to respawn to last checkpoint chunk index
    const saved = parseInt(localStorage.getItem('parkour_checkpoint_chunk')||'0');
    const idx = Math.max(0, saved);
    if(activeChunks[idx]){
      player.mesh.position.copy(activeChunks[idx].group.position).add(new THREE.Vector3(0,2,0)); player.velocity.set(0,0,0);
    } else { player.mesh.position.set(0,4,8); player.velocity.set(0,0,0); }
  }

  function saveCheckpoint(){ const chunkIdx = Math.max(0, Math.floor(Math.abs(player.mesh.position.z)/chunkDepth)-1); localStorage.setItem('parkour_checkpoint_chunk', chunkIdx); document.getElementById('cp').textContent = chunkIdx; }

  // -------------------- Init & helpers --------------------
  function spawnInitialChunks(seedValue){ setSeed(seedValue); // randomize theme & create chunks
    // choose rng and spawn
    rng = RNG(seedValue);
    // fill activeChunks with built chunks
    activeChunks.length=0; globalChunkIndex=0; for(let i=0;i<maxActiveChunks;i++){ const theme = pickTheme(rng); const c = buildChunk(globalChunkIndex++, rng, theme); activeChunks.push(c);} // update bboxes
    activeChunks.forEach(c=>c.bbox.setFromObject(c.group));
  }

  function setSeed(s){ seed = s; rng = RNG(seed); document.getElementById('seedLabel').textContent = seed; }

  // initial
  let maxActiveChunks = 10; let difficulty = 1.0; let seedStored = parseInt(localStorage.getItem('parkour_seed')||'0'); if(seedStored) setSeed(seedStored); else setSeed(Math.floor(Math.random()*2147483647)); spawnInitialChunks(seed);
  spawnBot(0xff6666); spawnBot(0x66ff99);
  startRun();
  animate();

  // resize
  window.addEventListener('resize', ()=>{ camera.aspect = window.innerWidth/window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); });

  // expose for debug
  window._parkourEpic = { scene, player, activeChunks, chunkPool, spawnInitialChunks, setSeed };
  </script>
</body>
</html>
