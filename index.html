<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Parkour 3D — Versão Funcional e Comentada</title>
  <style>
    /* Estilos básicos da página e HUD */
    html,body{height:100%;margin:0;background:#0b1020;overflow:hidden;font-family:Inter,Arial,sans-serif}
    #ui{position:fixed;left:12px;top:12px;color:#e6f0ff;z-index:20;background:rgba(6,10,20,0.45);padding:12px;border-radius:10px;backdrop-filter:blur(6px)}
    #hud{position:fixed;right:12px;top:12px;color:#e6f0ff;z-index:20;background:rgba(6,10,20,0.45);padding:10px;border-radius:10px}
    button{background:#2b4bff;color:white;border:0;padding:6px 10px;border-radius:6px;cursor:pointer}
    #msg{margin-top:8px;color:#bcd;font-size:13px}
    canvas{display:block}
  </style>
</head>
<body>
  <!-- Painel de controle e instruções -->
  <div id="ui">
    <div style="font-weight:700;margin-bottom:6px">Parkour 3D — Funcional & Comentado</div>
    <div>WASD — mover • Espaço — pular • Shift — correr • Clique — travar mouse</div>
    <div style="margin-top:8px"><button id="regen">Gerar novo percurso</button> <button id="toggleAI">AI Director: ON</button></div>
    <div id="msg">AI ajusta dificuldade automaticamente com base no seu desempenho.</div>
  </div>

  <!-- HUD com tempo, saltos e dificuldade -->
  <div id="hud">Tempo: <span id="time">0.00</span>s • Saltos: <span id="jumps">0</span> • Dificuldade: <span id="diff">Normal</span></div>

  <!-- Importa Three.js via CDN (versão UMD) -->
  <script src="https://unpkg.com/three@0.152.2/build/three.min.js">// --- SISTEMA DE PARKOUR INFINITO + ANTI-LAG ---\n// Lista de plataformas ativas\nlet activeChunks = [];\nlet chunkSize = 40; // distância entre chunks\nlet maxChunks = 8;  // máximo na memória para anti-lag\n\nfunction createChunk(zIndex){\n  const platform = new THREE.Mesh(\n    new THREE.BoxGeometry(6,1,6),\n    new THREE.MeshStandardMaterial({color:0x66c2ff})\n  );\n  platform.position.set((Math.random()*8)-4, 0, -zIndex*chunkSize);\n  scene.add(platform);\n  return platform;\n}\n\nfunction generateInitialChunks(){\n  for(let i=0;i<maxChunks;i++){\n    activeChunks.push(createChunk(i));\n  }\n}\n\nfunction updateChunks(){\n  const playerZ = player.mesh.position.z;\n\n  // Se o jogador passou do 3º chunk -> gera novo e remove o mais antigo\n  if(activeChunks.length > 0){\n    const first = activeChunks[0];\n    if(playerZ < first.position.z - chunkSize){\n      // remove chunk antigo\n      scene.remove(first);\n      activeChunks.shift();\n      // cria novo no final\n      const last = activeChunks[activeChunks.length-1];\n      const newChunk = createChunk((Math.abs(last.position.z)/chunkSize)+1);\n      activeChunks.push(newChunk);\n    }\n  }\n}\n\n// injeta chamada no loop principal\nconst oldAnimate = animate;\nanimate = function(){\n  updateChunks();\n  oldAnimate();\n};\n\n// inicia chunks\ngenerateInitialChunks();\n\n</script>

  <script>
  /*************************************************************************
   * Parkour 3D — Versão funcional, limpa e totalmente comentada (PT-BR)
   * Objetivo: jogo 3D simples de parkour com geração procedural, AI Director
   * (ajusta dificuldade), bots com comportamento básico e controles do jogador.
   * Salve este arquivo como index.html e abra no navegador.
   *************************************************************************/

  // ---------- Configuração básica da cena ----------
  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0x0b1020);
  scene.fog = new THREE.FogExp2(0x0b1020, 0.01);

  const renderer = new THREE.WebGLRenderer({antialias:true});
  renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.shadowMap.enabled = true;
  renderer.shadowMap.type = THREE.PCFSoftShadowMap;
  document.body.appendChild(renderer.domElement);

  const camera = new THREE.PerspectiveCamera(70, window.innerWidth/window.innerHeight, 0.1, 1000);
  camera.position.set(0,2,10);

  // ---------- Luzes ----------
  const hemi = new THREE.HemisphereLight(0xddeeff, 0x222233, 0.9);
  scene.add(hemi);
  const sun = new THREE.DirectionalLight(0xffffff, 1.0);
  sun.position.set(10,20,10);
  sun.castShadow = true;
  sun.shadow.mapSize.set(2048,2048);
  scene.add(sun);

  // ---------- Chão e ambiente ----------
  const ground = new THREE.Mesh(
    new THREE.PlaneGeometry(400,400),
    new THREE.MeshStandardMaterial({color:0x0d1630, roughness:0.95})
  );
  ground.rotation.x = -Math.PI/2;
  ground.position.y = -1;
  ground.receiveShadow = true;
  scene.add(ground);

  // ---------- Jogador (representado por uma caixa) ----------
  const player = {
    mesh: new THREE.Mesh(new THREE.BoxGeometry(0.9,1.8,0.9), new THREE.MeshStandardMaterial({color:0xfff0c1})),
    velocity: new THREE.Vector3(),
    speed: 6.5,
    onGround: false
  };
  player.mesh.castShadow = true;
  player.mesh.position.set(0,2,10);
  scene.add(player.mesh);

  // Offset da câmera (terceira pessoa)
  const camOffset = new THREE.Vector3(0,1.6,5.0);

  // ---------- Plataformas e geração procedural ----------
  const platforms = []; // array de {mesh, bbox}

  function createPlatform(x,y,z,w,h,d, color=0x6fbf73){
    // cria uma plataforma (caixa) e adiciona à cena e ao array
    const mat = new THREE.MeshStandardMaterial({color, metalness:0.05, roughness:0.8});
    const geo = new THREE.BoxGeometry(w,h,d);
    const mesh = new THREE.Mesh(geo, mat);
    mesh.position.set(x,y,z);
    mesh.castShadow = true; mesh.receiveShadow = true;
    scene.add(mesh);
    const bbox = new THREE.Box3().setFromObject(mesh);
    platforms.push({mesh, bbox});
    return mesh;
  }

  // Gera percurso procedural simples, controlado pela dificuldade do AIDirector
  function generateLevel(seed = Date.now()){
    // remove plataformas antigas
    for(const p of platforms){ scene.remove(p.mesh); }
    platforms.length = 0;

    // RNG simples com semente
    let s = seed % 2147483647;
    function rand(){ s = (s * 16807) % 2147483647; return (s-1)/2147483646; }

    const baseX = 0, baseY = 0, baseZ = 10;
    createPlatform(baseX, baseY, baseZ, 8,1.2,8, 0x4fb07f); // plataforma inicial

    // quantidade de plataformas escala com a dificuldade
    const count = Math.floor(8 + AIDirector.difficulty * 6);
    let x = baseX, y = baseY, z = baseZ;

    for(let i=0;i<count;i++){
      // gap (distância em z), variação em x e y e tamanho reduzido conforme dificuldade
      const gap = 3.2 + rand() * (1.8 + AIDirector.difficulty*2.2);
      const dx = (rand()-0.5) * 6.0 * (0.3 + AIDirector.difficulty*0.6);
      z -= gap; x += dx; y += (rand()-0.4) * 1.2;
      const w = Math.max(1.0, 2.6 - AIDirector.difficulty*0.8 + rand()*2.0);
      const d = Math.max(1.2, 2.2 - AIDirector.difficulty*0.8 + rand()*2.6);
      const h = 0.6 + rand()*0.6;
      createPlatform(x,y,z,w,h,d, 0x88c0ff + Math.floor(rand()*0x003300));
    }

    // plataforma final maior (finish)
    createPlatform(x+6, y+2, z-8, 10,1.2,10, 0xffd166);

    // após gerar, atualiza bounding boxes (útil se a geometria mudou)
    platforms.forEach(p => p.bbox.setFromObject(p.mesh));

    // reposiciona o jogador no início
    resetPlayerToStart();
    // reinicia estatísticas
    startRun();
  }

  // ---------- Sistema simples de bots (IA concorrente) ----------
  const bots = [];
  function spawnBot(color=0xff6666){
    const bot = {
      mesh: new THREE.Mesh(new THREE.BoxGeometry(0.7,1.6,0.7), new THREE.MeshStandardMaterial({color})),
      velocity: new THREE.Vector3(),
      targetIndex: 1
    };
    bot.mesh.castShadow = true;
    // posicionar na primeira plataforma
    if(platforms.length>0){
      const p = platforms[0].mesh.position;
      bot.mesh.position.set(p.x + (Math.random()-0.5)*1.5, p.y + 1.0, p.z + (Math.random()-0.5)*1.5);
    } else { bot.mesh.position.set(0,2,10); }
    scene.add(bot.mesh);
    bots.push(bot);
    return bot;
  }

  // Atualiza comportamento dos bots: navegam até a próxima plataforma
  function updateBots(dt){
    if(platforms.length===0) return;
    for(const bot of bots){
      const idx = Math.min(bot.targetIndex, platforms.length-1);
      const target = platforms[idx].mesh.position.clone();
      target.y += 1.0;
      const toTarget = target.clone().sub(bot.mesh.position);
      const horiz = toTarget.clone(); horiz.y = 0;
      const dist = horiz.length();
      if(dist>0.01){ horiz.normalize(); bot.mesh.position.addScaledVector(horiz, Math.min(3.0 * AIDirector.difficulty * dt, dist)); }

      // gravidade
      bot.velocity.y -= 20 * dt;
      bot.mesh.position.y += bot.velocity.y * dt;

      // colisão simples: se estiver dentro do bbox do target, avança
      const botBox = new THREE.Box3().setFromObject(bot.mesh);
      if(botBox.intersectsBox(platforms[idx].bbox)){
        // posiciona em cima da plataforma
        bot.mesh.position.y = platforms[idx].bbox.max.y + 0.8;
        bot.velocity.y = 0;
        bot.targetIndex = idx+1;
      }

      // se cair fora do mundo, respawn no início
      if(bot.mesh.position.y < -20){
        const p = platforms[0].mesh.position;
        bot.mesh.position.set(p.x + (Math.random()-0.5)*1.5, p.y + 1.0, p.z + (Math.random()-0.5)*1.5);
        bot.velocity.set(0,0,0);
        bot.targetIndex = 1;
      }
    }
  }

  // ---------- AIDirector: ajusta dificuldade com base no desempenho ----------
  const AIDirector = {
    enabled: true,
    difficulty: 1.0, // 0.6 = fácil, 1.0 normal, 1.8 difícil
    recentTimes: [],
    observeRun(timeSec, jumps){
      this.recentTimes.push(timeSec);
      if(this.recentTimes.length>6) this.recentTimes.shift();
      this.adjustDifficulty();
    },
    adjustDifficulty(){
      if(this.recentTimes.length<3) return; // espera amostra
      const avg = this.recentTimes.reduce((a,b)=>a+b,0)/this.recentTimes.length;
      // heurística simples: tempo baixo => aumentar, tempo alto => diminuir
      if(avg < 12) this.difficulty = Math.min(1.8, this.difficulty + 0.08);
      else if(avg > 18) this.difficulty = Math.max(0.6, this.difficulty - 0.08);
      // atualiza HUD
      updateDifficultyLabel();
    }
  };

  function updateDifficultyLabel(){
    const el = document.getElementById('diff');
    const val = AIDirector.difficulty;
    let name = 'Normal'; if(val>1.4) name='Difícil'; else if(val<0.8) name='Fácil';
    el.textContent = name + ' (' + val.toFixed(2) + ')';
  }

  // ---------- Controles do jogador (keyboard + pointer lock para olhar) ----------
  const keys = { w:false,a:false,s:false,d:false, shift:false };
  window.addEventListener('keydown', e=>{ if(e.code==='KeyW') keys.w=true; if(e.code==='KeyS') keys.s=true; if(e.code==='KeyA') keys.a=true; if(e.code==='KeyD') keys.d=true; if(e.code==='ShiftLeft') keys.shift=true; if(e.code==='Space') tryJump(); });
  window.addEventListener('keyup', e=>{ if(e.code==='KeyW') keys.w=false; if(e.code==='KeyS') keys.s=false; if(e.code==='KeyA') keys.a=false; if(e.code==='KeyD') keys.d=false; if(e.code==='ShiftLeft') keys.shift=false; });

  // Implementação de mouse look com Pointer Lock API
  let pointerLocked = false;
  let yaw = 0, pitch = 0;
  renderer.domElement.addEventListener('click', ()=> renderer.domElement.requestPointerLock());
  document.addEventListener('pointerlockchange', ()=>{ pointerLocked = !!document.pointerLockElement; });
  document.addEventListener('mousemove', e=>{
    if(!pointerLocked) return;
    yaw -= e.movementX * 0.0025;
    pitch -= e.movementY * 0.0025;
    pitch = Math.max(-1.2, Math.min(1.2, pitch));
  });

  // ---------- Física e colisão do jogador ----------
  function tryJump(){ if(player.onGround){ player.velocity.y = 8.6; player.onGround = false; jumpCount++; document.getElementById('jumps').textContent = jumpCount; } }

  function resetPlayerToStart(){
    // posiciona o jogador sobre a primeira plataforma
    if(platforms.length>0){
      const p = platforms[0].mesh.position;
      player.mesh.position.set(p.x, p.y + 1.0 + 0.9, p.z);
      player.velocity.set(0,0,0);
    } else {
      player.mesh.position.set(0,2,10); player.velocity.set(0,0,0);
    }
    yaw = 0; pitch = 0;
  }

  // ---------- Estatísticas do run ----------
  let jumpCount = 0; let levelStart = performance.now();
  function startRun(){ levelStart = performance.now(); jumpCount = 0; document.getElementById('jumps').textContent = 0; }
  function endRun(){ const total = (performance.now() - levelStart) / 1000; AIDirector.observeRun(total, jumpCount); }

  // ---------- Início: gerar nível e spawnar bots ----------
  generateLevel();
  spawnBot(0xff6666); spawnBot(0x66ff99);

  // ---------- UI: botões para regenerar e toggle AI ----------
  document.getElementById('regen').addEventListener('click', ()=>{ generateLevel(Date.now()); // remove bots e respawna
    for(const b of bots) scene.remove(b.mesh);
    bots.length = 0; spawnBot(0xff6666); spawnBot(0x66ff99); startRun();
  });
  const toggleAI = document.getElementById('toggleAI'); toggleAI.addEventListener('click', ()=>{ AIDirector.enabled = !AIDirector.enabled; toggleAI.textContent = 'AI Director: ' + (AIDirector.enabled? 'ON':'OFF'); });

  // ---------- Loop principal (render + física) ----------
  const clock = new THREE.Clock();
  function animate(){
    const dt = Math.min(0.05, clock.getDelta());

    // movimento do jogador — relativo à orientação (yaw)
    const dir = new THREE.Vector3();
    if(keys.w) dir.z -= 1; if(keys.s) dir.z += 1; if(keys.a) dir.x -= 1; if(keys.d) dir.x += 1;
    if(dir.lengthSq()>0) dir.normalize();

    const forward = new THREE.Vector3(Math.sin(yaw),0,Math.cos(yaw));
    const right = new THREE.Vector3(Math.cos(yaw),0,-Math.sin(yaw));
    const baseSpeed = keys.shift? player.speed * 1.6 : player.speed;
    const move = new THREE.Vector3();
    move.addScaledVector(forward, dir.z * baseSpeed * dt);
    move.addScaledVector(right, dir.x * baseSpeed * dt);
    player.mesh.position.add(move);

    // gravidade
    player.velocity.y -= 20 * dt;
    player.mesh.position.y += player.velocity.y * dt;

    // colisão com plataformas — AABB simples
    const pBox = new THREE.Box3().setFromObject(player.mesh);
    player.onGround = false;
    for(const p of platforms){
      // atualizar bbox caso a plataforma tenha mudado
      p.bbox.setFromObject(p.mesh);
      if(pBox.intersectsBox(p.bbox)){
        const platTop = p.bbox.max.y;
        // se o jogador estiver acima (queda), aterrisse
        if(player.mesh.position.y - 0.9 <= platTop + 0.2){
          player.mesh.position.y = platTop + 0.9;
          player.velocity.y = 0;
          player.onGround = true;
        } else {
          // empurra para fora no eixo de menor sobreposição — solução simples
          const overlapX = Math.min(pBox.max.x, p.bbox.max.x) - Math.max(pBox.min.x, p.bbox.min.x);
          const overlapZ = Math.min(pBox.max.z, p.bbox.max.z) - Math.max(pBox.min.z, p.bbox.min.z);
          if(overlapX < overlapZ){
            if(pBox.getCenter(new THREE.Vector3()).x < p.bbox.getCenter(new THREE.Vector3()).x) player.mesh.position.x -= overlapX + 0.01;
            else player.mesh.position.x += overlapX + 0.01;
          } else {
            if(pBox.getCenter(new THREE.Vector3()).z < p.bbox.getCenter(new THREE.Vector3()).z) player.mesh.position.z -= overlapZ + 0.01;
            else player.mesh.position.z += overlapZ + 0.01;
          }
        }
      }
    }

    // Atualiza bots
    updateBots(dt);

    // Previne queda infinita
    if(player.mesh.position.y < -40) resetPlayerToStart();

    // Update da câmera: suaviza seguindo o jogador
    const camTarget = player.mesh.position.clone().add(new THREE.Vector3(0,1.0,0));
    const desiredCam = camTarget.clone().add(new THREE.Vector3(Math.sin(yaw)*camOffset.z, camOffset.y, Math.cos(yaw)*camOffset.z));
    camera.position.lerp(desiredCam, 0.12);
    camera.lookAt(camTarget);

    // Detecta chegada na plataforma final (última)
    const finishPlat = platforms[platforms.length-1];
    if(finishPlat){
      if(pBox.intersectsBox(finishPlat.bbox)){
        // fim do run — registra e gera novo nível com ajuste de dificuldade
        endRun();
        if(AIDirector.enabled) { /* dificuldade ajustada internamente */ }
        // pequena celebração visual: piscar background (exemplo simples)
        const original = scene.background.clone();
        scene.background = new THREE.Color(0x3a6fff);
        setTimeout(()=>{ scene.background = original; generateLevel(Date.now()); }, 800);
      }
    }

    // HUD
    document.getElementById('time').textContent = ((performance.now() - levelStart)/1000).toFixed(2);
    updateDifficultyLabel();

    renderer.render(scene, camera);
    requestAnimationFrame(animate);
  }

  // ---------- Redimensionamento ----------
  window.addEventListener('resize', ()=>{
    camera.aspect = window.innerWidth/window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  });

  // ---------- Start inicial ----------
  startRun();
  animate();

  // ---------- Expõe utilitários para depuração no console (opcional) ----------
  window._parkour = { scene, player, platforms, bots, AIDirector, generateLevel };

  </script>
</body>
</html>
